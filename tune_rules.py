#!/usr/bin/env python3
import datetime
import os
import sys
import argparse
import copy
import collections
import dill  # For pickle-ing lambdas need to use 'dill' package.
from typing import Any, List, Dict, Tuple
import contextlib
import aw_client
# Don't use convenient pyinput because https://pynput.readthedocs.io/en/latest/limitations.html#platform-limitations
# For Unix terminal:
try:
    import termios
except ImportError:
    pass
# For Windows terminal:
try:
    import msvcrt
except ImportError:
    pass
from pick import pick

from activity_merger.config.config import LOG, MIN_DURATION_SEC, RULES, BUCKET_DEBUG_RAW_RULE_RESULTS
from activity_merger.domain.input_entities import Event, Rule2
from activity_merger.domain.interval import Interval, intervals_duration
from activity_merger.helpers.helpers import event_data_to_str, setup_logging, valid_date, seconds_to_int_timedelta
from activity_merger.domain.analyzer import analyze_intervals, ProblemReporter, find_rule_for_event
from activity_merger.domain.output_entities import AnalyzerResult
from activity_merger.domain.metrics import Metrics
from activity_merger.domain.tuner import IntervalWithDecision, SKIP_TEXT, MERGE_TEXT, TUNER_ABILITIES_TEXT,\
                                         adjust_priorities
from get_activities import get_interval, reload_debug_buckets


class Context:  # TODO move to 'tuner.py'.
    """
    Container for "tune rules" data. Allows save and restore data.
    """
    USED_RULES_METRIC_NAME = 'used rules'
    FOUND_ACTIVITIES_METRIC_NAME = 'found activities'
    SAVE_FILE_PATH = os.path.abspath("tune_rules-context.dill")

    def __init__(self, intervals: List[IntervalWithDecision], rules: List[Rule2])\
            -> None:
        self.intervals: List[IntervalWithDecision] = intervals
        self.rules: List[Rule2] = rules

    def save(self):
        """
        Saves itself into `SAVE_FILE_PATH` file.
        """
        # We can't save 'self' as is due to deep recursions in Interval-s.
        # Prepare copy which may be restored into full object on "load".
        serializable_intervals = [x.get_serializable_copy() for x in self.intervals]
        tmp = Context(serializable_intervals, self.rules)
        with open(Context.SAVE_FILE_PATH, "wb") as f:
            dill.dump(tmp, f)
        LOG.info("Saved current context into %s file.", Context.SAVE_FILE_PATH)

    @staticmethod
    def read_from_file() -> 'Context':
        """
        Reads context of tuning from the `SAVE_FILE_PATH` file.
        """
        with open(Context.SAVE_FILE_PATH, "rb") as f:
            result: Context = dill.load(f)
            intervals = []
            prev = None
            # Note that `intervals` are stored without `next` and `prev` fields to avoid recursion.
            # Restore these links assuming that intervals were saved in order of initial linked list.
            for i, interval in enumerate(result.intervals):
                # Get `prev`.
                if i == 0:
                    prev = None
                else:
                    prev = intervals[-1]
                # Append deep copies (not de-serialized objects) to restore all methods on 'custom' class objects.
                intervals.append(IntervalWithDecision.from_serializable_copy(interval, prev))
            result.intervals = intervals
        undecided_intervals = result.get_undecided_intervals()
        total_rules = result.get_number_of_rules()
        LOG.info("Restored context from '%s' file with %d/%d undecided intervals and %d rules.",
                 Context.SAVE_FILE_PATH, len(undecided_intervals), len(result.intervals), total_rules)
        return result

    def get_undecided_intervals(self) -> List[IntervalWithDecision]:
        """
        :return: List of `IntervalWithDecision`-s which are not decided yet.
        """
        return [x for x in self.intervals if not x.decision]

    def get_number_of_rules(self) -> int:
        """
        :return: Number of `Rule`-s inside.
        """
        result = 0
        for rule in self.rules:
            result += rule.get_number_of_rules_in_tree()
        return result

    def set_rules_to_intervals(self) -> Metrics:
        """
        Sets rules for all events inside all intervals inside.
        :return: `Metrics` with information about used rules.
        Is populated with metrics:
        - `USED_RULES_METRIC_NAME` - rules which matches events,
        - `FOUND_ACTIVITIES_METRIC_NAME` - activities generated by rules,
        - metric per each rule (not generated activity!).
        """
        metrics = Metrics({})
        used_rules = set()
        activities = set()
        for interval in self.intervals:
            rules = []
            for event in interval.events:
                rule, description = find_rule_for_event(event, self.rules)
                if rule:
                    rules.append(rule)
                    rule_name = str(rule)
                    metrics.increment(rule_name, interval)
                    used_rules.add(rule_name)
                    activities.add(description)
            interval.rules = sorted(rules)
        metrics.override(Context.USED_RULES_METRIC_NAME, len(used_rules), 0)
        metrics.override(Context.FOUND_ACTIVITIES_METRIC_NAME, len(activities), 0)
        return metrics


class ItemToDecide():
    __slots__ = ('rules', 'intervals', 'sum_duration', 'decision')
    
    def __init__(self, rules: List[Rule2], intervals: List[IntervalWithDecision], sum_duration):
        self.rules = rules
        self.intervals = intervals
        self.sum_duration = sum_duration
        self.decision = None

    def set_user_decision(self, decision):
        self.decision = decision
        for interval in self.intervals:
            interval.decision = decision

    def to_str(self) -> str:
        rules_str = [str(x) for x in self.rules]
        examples = [self.intervals[0].to_str()]
        if len(self.intervals) > 1:
            examples.append(self.intervals[1].to_str())
        return '%d intervals on %s which capture rules:\n  %s\nExamples:\n  %s' % \
               (len(self.intervals), seconds_to_int_timedelta(self.sum_duration), "\n  ".join(rules_str),
                "\n  ".join(examples))


def _find_items_to_decide(decisions: List[IntervalWithDecision]) -> List[ItemToDecide]:
    metrics = Metrics({})
    input_rules_to_intervals: Dict[Tuple[Rule2], List[IntervalWithDecision]] = {}
    for decision in decisions:
        input_rules = set(decision.rules)
        input_rules_tuple = tuple(sorted(input_rules, key=lambda r: r.key_pattern))
        intervals_with_same_rules = input_rules_to_intervals.get(input_rules_tuple)
        if intervals_with_same_rules:
            intervals_with_same_rules.append(decision)
            metrics.increment('intervals with same rules', decision)
            metrics.increment(str(input_rules_tuple), decision)
        else:
            input_rules_to_intervals[input_rules_tuple] = [decision]
    LOG.info("Found %d items to decide:\n  %s",
             len(input_rules_to_intervals), "\n  ".join(metrics.to_strings()))
    return [ItemToDecide(k, v, intervals_duration(v)) for k, v in input_rules_to_intervals.items()]


class TerminalLeader:
    """
    Abstract matching song leader which expects user answers in terminal. Wraps `Matcher`, manages "ask - answer -
    check" flow and prints statistic at the end. Delegates operating system specific actions to inheritors.
    """

    def __init__(self):
        pass

    def read_user_input(self) -> str:
        return input()

    def clean_lines(self, cnt: int):
        raise NotImplementedError()

    def ask_yes_no(self, question_without_yn: str) -> bool:
        """
        Prints question, appends ' [y/N]: ' legend to it and waits answer.
        :param question_without_yn: Question string/sentence.
        :return: `True` if user answered yes, `False` otherwise.
        """
        sys.stdout.write(question_without_yn + " [y/n]: ")
        sys.stdout.flush()
        result = self.read_user_input().lower() == "y"
        sys.stdout.write("\n")
        sys.stdout.flush()
        return result

    def _ask_multiselect_question(self, question: str, options: List[str]) -> List[str]:
        """
        Draws multiple lines of text on the screen with options to choose one or few. Cleans console after itself.
        :param question: Question choose options for.
        :param options: List of options to choose.
        :return: List of chosen options.
        """
        # 'pick' library cleans screen and draws menu with options. At end disappears and leaves old content.
        result = pick(options, question, multiselect=True, default_index=2, min_selection_count=1)
        return result

    def _ask_decision(self, item_to_decide: ItemToDecide) -> List[Any]:
        interval_desc = item_to_decide.to_str()
        options = {  # Use keys as 'value to present to user' and values to return result.
            SKIP_TEXT: IntervalWithDecision.SKIP,
            MERGE_TEXT: IntervalWithDecision.MERGE_NEXT,
        }
        for rule in item_to_decide.rules:
            options[str(rule)] = rule
        # Start loop of asking. Because some answers may contradict each other.
        result_desc_items: List[str]
        result = []
        while True:
            selected: List[str] = self._ask_multiselect_question(interval_desc, list(options.keys()))
            # Check for validity.
            if SKIP_TEXT in selected and MERGE_TEXT in selected:
                LOG.warning("It is impossible to choose both %s and %s. Please reconsider.", SKIP_TEXT, MERGE_TEXT)
                continue
            # Build text explanation of choice.
            result_desc_items = []  # Clear from previous attempt values.
            result = []
            for key in selected:
                value = options.get(key, None)
                result.append(value)
                if isinstance(value, Rule2):
                    result_desc_items.append(str(value))
                elif value == IntervalWithDecision.SKIP:
                    result_desc_items.append('skip')
                elif value == IntervalWithDecision.MERGE_NEXT:
                    result_desc_items.append('merge with next')
                else:
                    raise ValueError(f"Got wrong selected option '{key}.")
            break
        LOG.info("%s %s", interval_desc, ', '.join(result_desc_items))
        return result

    def ask_decisions(self, items_to_decide: List[ItemToDecide]) -> bool:
        """
        Interacts with user asking decisions for given list of items. At start displays legend and asks if need
        proceed.
        :param items_to_decide: List of items to make decision for.
        :return: `True` if need to stop tuning and just print result, `False` to proceed with one more iteration. 
        """
        sys.stdout.write(  # TODO 1. Rewrite to "items". 2 Reduce coupling with 'tuner'.
            "INSTRUCTION: Please open chosen date on http://localhost:5600/#/timeline to see '%s' bucket debug "
            "events. Note that with all debug events this page may be quite slow in browser. "
            "You will be asked about all %d intervals from '%s' bucket to chose how given interval should be "
            "handled in order to provide right 'activity' in resulting report."
            "\nNote that always better to choose one or multiple recorded events because:\n"
            "- %s - need to point event causing skipping.\n"
            "- %s - need to point event which makes this interval borrow meaning of the next interval. "
            "Choose 'afk' bucket event if you don't sure/know what happened those time.\n"
            "- in all cases - because more data means more precision.\n"
            "Sometimes lack of events or 'too general events' on interval just means that need to add more rules "
            "into configuration to provide more information for decisions.\n"
            "Tuner may do the following corrections to rules: %s.\n"
            "So point your decision (with \u2191 and \u2193) and press 'Space' on one or few options. "
            "Press 'Enter' to apply and proceed. Press 'Escape' or choose nothing to stop deciding. "
            "If you haven't provided decision for each interval then remained will be re-evaluated with existing "
            "decisions. Note that all contradicting decisions will be noted and handed by 'first decision' strategy.\n"
             % (BUCKET_DEBUG_RAW_RULE_RESULTS, len(items_to_decide), BUCKET_DEBUG_RAW_RULE_RESULTS, SKIP_TEXT,
                MERGE_TEXT, TUNER_ABILITIES_TEXT)
        )
        sys.stdout.flush()
        if not self.ask_yes_no("Proceed with 'decide for intervals' session?"):
            return True
        cnt_decided = 0
        for item_to_decide in items_to_decide:  # TODO add 'redo' or 'next'.
            selected = self._ask_decision(item_to_decide)
            if selected:
                item_to_decide.set_user_decision(selected)
                cnt_decided += 1
            elif self.ask_yes_no(f"Decided only {cnt_decided} from {len(items_to_decide)} intervals. "
                                 "Are you sure you want to stop earlier?"):
                break
        return False


class UnixTerminalLeader(TerminalLeader):
    """
    TerminalLeader for Unix machines. Relies on VT100 escape codes and TTY.
    """

    # FYI: https://wiki.bash-hackers.org/scripting/terminalcodes
    ANSI_CURSOR_UP = '\x1b[1A'  # Move cursor up (don't forget '\r' to put it on start of line).
    ANSI_CURSOR_SAVE_POSITION = '\033[s'#'\x1b7'
    ANSI_CURSOR_TO_SAVED = '\033[u'#'\x1b8'
    ANSI_CLEAR_CURRENT_LINE = '\x1b[2K'  # Clear the whole line where cursor is placed.
    ANSI_CLEAR_PREVIOUS_LINE = '\033[A'
    ANSI_CLEAR_TO_END_OF_SCREEN = '\033[J'#'\x1b[J'
    ANSI_HIDE_CURSOR = '\033[?25l'
    ANSI_SHOW_CURSOR = '\033[?25h'
    ANSI_FONT_DECORATION_STOP = '\u001b[0m'
    ANSI_FONT_DECORATION_BOLD = '\u001b[1m'
    ANSI_FONT_DECORATION_UNDERLINE = '\u001b[4m'
    ANSI_SHIFT_CURSOR_LEFT_PREFIX = '\u001b['
    ANSI_SHIFT_CURSOR_LEFT_SUFFIX = 'D'
    KEY_ESC = '\u00001b' #  '\x1b'
    KEY_UP = '\u1b5b41' # '\x1b[A'
    KEY_DOWN = '\u1b5b42' #  '\x1b[B'
    KEY_LEFT = '\u1b5b44' #  '\x1b[D'
    KEY_RIGHT = '\u1b5b43' # '\x1b[C'

    def clean_lines(self, cnt: int):
        sys.stdout.write("".join([self.ANSI_CLEAR_PREVIOUS_LINE] * cnt))
        sys.stdout.flush()

    def ask_yes_no(self, question_without_yn: str) -> bool:
        # Also cleans question from the console.
        self._save_cursor_position()
        sys.stdout.write(question_without_yn + " [y/n]: ")
        sys.stdout.flush()
        result = input().lower() == "y"
        self._clear_up_to_saved_position()
        return result

    def _save_cursor_position(self):
        sys.stdout.write(self.ANSI_CURSOR_SAVE_POSITION)

    def _clear_up_to_saved_position(self):
        sys.stdout.write(self.ANSI_CURSOR_TO_SAVED + self.ANSI_CLEAR_TO_END_OF_SCREEN)
        sys.stdout.flush()

    def _save_cursor_position_and_print_multiselect_question(self, question: str, menu: List[List]):
        # item = [description, is_cursor, is_selected]
        self._save_cursor_position()
        sys.stdout.write('\n' + question)
        for item in menu:
            buffer = '\n '
            buffer += '-> (' if item[1] else '   ('
            buffer += '*) ' if item[2] else ' ) '
            buffer += item[0]
            sys.stdout.write(buffer)
        sys.stdout.flush()

    def _multiselect_question_move_cursor_and_reprint(self, question: str, menu: List[List], is_down: bool):
        pointed = [i for i, x in enumerate(menu) if x[1]]  # Get index or empty list.
        # Calculate desired position.
        desired_position: int
        if not pointed:
            desired_position = 0
        else:
            current_position = pointed[0]
            desired_position = current_position
            if is_down:
                if current_position < len(menu) - 1:
                    desired_position = current_position + 1
            else:
                if current_position > 0:
                    desired_position = current_position - 1
        # Change position.
        menu[current_position][1] = False
        menu[desired_position][1] = True
        # Note that `self.clean_lines(cnt)` works wrong after long lines being split due to lenght.
        self._clear_up_to_saved_position()
        self._save_cursor_position_and_print_multiselect_question(question, menu)

    def _multiselect_question_switch_option_and_reprint(self, question: str, menu: List[List]):
        for item in menu:
            if item[1]:
                item[2] = not item[2]
                self._multiselect_question_move_cursor_and_reprint(question, menu, True)
                return

    def _ask_multiselect_question(self, question: str, options: List[str]) -> List[str]:
        if not options:  # Avoid errors on building menu (simplified code below)
            raise ValueError("_ask_multiselect_question: Empty options are provided.")
        # Modify TTY. Based on https://stackoverflow.com/a/47955341 and https://stackoverflow.com/a/47197390/1535127
        # Save and clone TTY attributes.
        fd = sys.stdin.fileno()
        old = termios.tcgetattr(fd)
        new = termios.tcgetattr(fd)
        # Correct TTY attributes to read single key strokes. See https://man7.org/linux/man-pages/man3/termios.3.html
        new[3] = new[3] & ~termios.ICANON & ~termios.ECHO
        # Start block of changes which should be reverted afterwards.
        try:
            # Prepare menu. Set pointer on the first option.
            menu = [[x, False, False] for x in options]
            menu[0][1] = True
            # Hide cursor and print question with menu.
            # NOTE breaks cursor movements in xfce4-terminal sys.stdout.write(self.ANSI_HIDE_CURSOR)
            self._save_cursor_position_and_print_multiselect_question(question, menu)
            # Apply TTY modifications.
            termios.tcsetattr(fd, termios.TCSANOW, new)
            is_exit = False
            # Listen key strokes and modify menu.
            while True:
                event = os.read(fd, 3).decode()
                if len(event) == 3:
                    code = ord(event[2])  # All 3 numbers mean special key when code is a last number.
                    if code == 65:  # Up
                        self._multiselect_question_move_cursor_and_reprint(question, menu, False)
                    elif code == 66:  # Down
                        self._multiselect_question_move_cursor_and_reprint(question, menu, True)
                elif len(event) == 1:
                    if event[0] == ' ':  # Space to set/unset menu item.
                        self._multiselect_question_switch_option_and_reprint(question, menu)
                    elif event[0] == '\n':  # Enter
                        is_exit = True
                    elif event[0] == '\x1b':  # Escape
                        for item in menu:  # Clean all selected options to simulate "I just want to exit!".
                            item[2] = False
                        is_exit = True
                if is_exit:
                    self._clear_up_to_saved_position()
                    break
        finally:
            # Revert TTY attributes.
            # TODO fix - doesn't revert in xfce4-terminal. STR: run once, stop, try again - menu doesn't clean.
            termios.tcsetattr(fd, termios.TCSADRAIN, old)
            # NOTE breaks cursor movements in xfce4-terminal sys.stdout.write(self.ANSI_SHOW_CURSOR)
        return [x[0] for x in menu if x[2]]


def ask_decisions_and_correct_rules(context: Context) -> bool:
    """
    Interacts with user asking about required intervals decisions, next makes suggestion for "analyze" rules.
    :param context: Context with "what to ask" and current progress.
    :return: `True` if user chose to stop tuning, `False` if all decisions were made.
    """
    if sys.platform.startswith("win"):
        LOG.error("Windows terminal is not supported yet")
        # leader = WindowsTerminalLeader() TODO
    else:
        leader = UnixTerminalLeader()
    # Calculate which decisions need to make.
    undecided_intervals: List[IntervalWithDecision] = context.get_undecided_intervals()
    # Find out rules for all intervals.
    metrics = context.set_rules_to_intervals()
    LOG.info("Have set rules for all events in all %d intervals. From %d total rules were used:\n  %s",
             len(context.intervals), context.get_number_of_rules(), "\n  ".join(metrics.to_strings()))
    # Get unique rules combination to make decisions for.
    items_to_decide: List[ItemToDecide] = _find_items_to_decide(context.intervals)
    # Interact with user asking for decisions like "this event describes this interval".
    is_exit = leader.ask_decisions(items_to_decide)
    # Find out which intervals were decided on this round.
    decided_items_this_round = [x for x in items_to_decide if x.decision]
    # TODO need provide distinguishable good to_str() for Rules including bucket ID.
    # TODO work with ItemToDecide-s futher
    decided_intervals: List[IntervalWithDecision] = [x for x in context.decisions if x.decision]
    LOG.info("Got decisions for %d from %d asked intervals. Total %d decided intervals from %d.",
             len(decided_items_this_round), len(undecided_intervals), len(decided_intervals),
             len(context.decisions))
    # Check if something was changed and adjust rules if yes.
    if decided_intervals:
        # Investigated decisions and adjust priorities for rules.
        metrics = adjust_priorities(decided_intervals)
        LOG.info("By %d decided intervals on this round made following adjustments to rules:\n%s",
                 len(decided_items_this_round), metrics.to_strings())
        # Use metrics to calculate percentage of changes.
        total_rules = metrics.get_metric('total_rules')
        total_unique_updated_rules = metrics.get_metric('total_unique_updated_rules')
        # TODO output rules 'to paste into file'.
        LOG.info("Adjusted %f.2%% rules. Result:\n%s  ", 100 * (total_unique_updated_rules / total_rules), context.rules)
    return is_exit


def tune_rules(events_date: datetime.datetime, is_use_saved_context: bool):
    """
    Gets all ActivityWatch events for the specified date, builds linked list of intervals from them,
    analyzes intervals, converts them into combined activities by specified (and fine-tuned per person) rules,
    prints them into output.
    :param events_date: Date to work with events on.
    :param is_use_saved_context: Flag to read data saved from previous run.
    :return: 'AnalyzerResult' object or 'None' if no intervals to analyze were found.
    """
    client = aw_client.ActivityWatchClient(os.path.basename(__file__))
    if is_use_saved_context:
        context = Context.read_from_file()
    else:
        # Build time-ordered linked list of intervals by provided events.
        interval = get_interval(events_date, client)
        if interval is None:
            LOG.warning("Can't find events/intervals for %s. Doing nothing.", events_date.date())
            return None
        # Scroll to the first/oldest interval.
        interval = interval.iterate_prev()
        # Prepare context: make Decision-s from Interval-s and make deep clone of rules.
        intervals_list = []
        interval.iterate_next(lambda x: intervals_list.append(IntervalWithDecision(x)))
        context = Context(intervals_list, copy.deepcopy(RULES))
        # Save context right away to skip steps above next time.
        context.save()
    analyzer_result: AnalyzerResult
    LOG.info("---- Tuning started.")
    skip_problems = set(ProblemReporter.SUPPORTED_ITEMS.keys())
    while True:
        # Analyze intervals, upload debug buckets, provide user with current state.
        analyzer_result = analyze_intervals(context.intervals[0], MIN_DURATION_SEC, context.rules,
                                            is_build_debug_buckets=True, ignore_hints=skip_problems)
        reload_debug_buckets(analyzer_result, client)
        LOG.info(analyzer_result.to_str(0.0))
        # Interact with user.
        is_exit = ask_decisions_and_correct_rules(context)
        # TODO provide ability to reset some decisions (is_exit -> EXIT/APPLY_AND_SAVE/ONLY_APPLY)
        context.save()
        if is_exit:
            break
    LOG.info("---- Tuning completed.")
    # Provide user with resulting state. Don't skip problems this time.
    LOG.info(analyzer_result.to_str())
    return analyzer_result


def main():
    parser = argparse.ArgumentParser(
        description="Makes the same as 'get_activities' but together with providing result asks user about "
                    "what they expect and suggests corrections to current rules.\n"
                    "Can't make new rules and somehow correct configuration file. All these actions are manual!\n"
                    "In details it:\n"
                    "1. calls AcivityWatch for all available events on specified date,\n"
                    "2. merges all events by initial or built in previous run rules into linked list of 'intervals',\n"
                    "3. analyzes 'intervals' and makes 'actvities' from them,\n"
                    "4. imports analyzing intermediate results into AcivityWatch as events in 'debug' buckets,\n"
                    "5. asks user what is expected to be dominant event for all or 'arguable' intervals,\n"
                    "6. basing on answers corrects initial rules in-memory and saves context in file,\n"
                    "7. analyzes 'intervals' again (steps 3-4) and asks if need to improve existing rules further,\n"
                    "8. if tuned rules are OK or needs to manual correction then prints them and exits.\n",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('date', nargs='?', type=valid_date,
                        help="Date to analyze AcivityWatch events in format 'YYYY-mm-dd'. By-default is today. "
                             "If omit here but set 'back days' argument then date is calculated as today - back_days.")
    parser.add_argument('-b', '--back-days', type=int,
                        help="How many days back search events on. I.e. '1' value means 'search for yesterday.")
    parser.add_argument('-l', '--load-context', dest='is_use_saved', action='store_true',
                        help="Flag to load saved context from previous execution.")
    args = parser.parse_args()
    events_date = args.date if args.date else datetime.datetime.today().astimezone()
    if args.back_days and args.back_days > 0:
        events_date = (events_date - datetime.timedelta(days=args.back_days))
    tune_rules(events_date, args.is_use_saved)


@contextlib.contextmanager  # TODO remove after fixing all terminal issues
def raw_mode(file):
    old_attrs = termios.tcgetattr(file.fileno())
    new_attrs = old_attrs[:]
    new_attrs[3] = new_attrs[3] & ~(termios.ECHO | termios.ICANON)
    try:
        termios.tcsetattr(file.fileno(), termios.TCSADRAIN, new_attrs)
        yield
    finally:
        termios.tcsetattr(file.fileno(), termios.TCSADRAIN, old_attrs)


def main2():  # TODO remove after fixing all terminal issues
    print('exit with ^C or ^D')
    with raw_mode(sys.stdin):
        try:
            while True:
                ch = sys.stdin.read(1)
                if not ch or ch == chr(4):
                    break
                print('%02x' % ord(ch))
        except (KeyboardInterrupt, EOFError):
            pass


if __name__ == '__main__':
    LOG = setup_logging()
    main()
